%% ------------------------------------------------------------------------- %%
%\chapter{Desenvolvimentos}
%\label{cap:desenvolvimentos}
%
%Embora neste exemplo tenhamos apenas um capítulo,  entre a introdução
%e a conclusão de uma monografia podemos ter uma sequência de capítulos
%descrevendo o trabalho e os resultados. Estes podem descrever
%fundamentos, trabalhos relacionados, método/modelo/algoritmo proposto,
%experimentos realizados, resulatdos obtidos.
%
%Cada capítulo pode ser organizado em seções, que por sua vez pode
%conter subseções.
%
%Um exemplo de figura está na figura~\ref{fig:graph}.
%\begin{figure}[htb]
%\includegraphics[width=5cm]{figuras/graph}
%\caption{\label{fig:graph}Exemplo de uma figura.}
%\end{figure}
\chapter{Desenhando objetos}
\label{cap:desenvolvimentos}
% O objetivo deste capítulo é expor as técnicas e decisões para gerar as imagens das cartas no
% celular

% Introduzir aos conceitos básicos de imagens, perspectiva, visão e objetos em relação á conputação
% gráfica, as tecnologias como biblioteca gráfica e bibliotecas do android para desenvolvimento de
% aplicativos

% Explicar as decisões tomadas no desenvolvimento do GL(biblioteca gráfica no aplicativo). Explicar
% as abstrações que foram feitas para obter o GL.

% Mostras testes de experimento de tempo durante o processo de otimização.

Para desenhar imagens de cartas, fundo e botões na tela do celular, fizemos uso da interface de
programação de aplicações do Android e do OpenGL.

O Android pode ser visto como uma camada de abstração da interface de manipulação da tela do celular e
do sensor de toque da tela disponibilisados pelos fabricantes. Nosso aplicativo faz uso desses
dispositivos, por meio desta camada e não iremos nos preocupar como essa abstração foi implementada.

Um aplicativo para Android é construido com componetes. Cada componete é um diferente ponto de entrada
do sistema. Existem quatro tipos diferentes de componetes: Activities, Services, Content providers e
Broadcast receivers, cada qual responsável por alguma funcionalidade dentro do aplicativo.

Nesta etapa de desenvolvimento, faremos uso da componete Activity. Uma activity representa uma tela
única com uma interface de usuário. Afim de gerar imagens para serem desenhadas nesta tela, faremos
uso do OpenGL ES.

O OpenGL é um conjunto de comandos que permitem a especificação de objetos geométricos em duas ou
três dimenções, junto com comandos que controlam como esses objetos são renderizados no
{\it framebuffer}. Esses objetos geométricos são construidos com {\it primitivas} que podem ser ponto,
segmento de linha, ou triângulo. As primitivas são definidas por um grupo de um ou mais vértices. Os
vértices definem um ponto, ponto final de uma aresta ou canto de um triângulo onde duas arestas se
encontram e são representados como um subconjunto de \(\mathbb{R}²\). Informações como coordenadas de
posição, cores, normal, coordenadas de textura podem estar associados a um vértice. As primitivas
formadas pelos vértices em \(\left\{\left(x, y\right) \in \mathbb{R}² | -1 \leq x, y \leq 1\right\}\)
são enviados para serem mostrados na tela, chamaremos esses vértices de vértices visíveis.

Inicialmente haviamos escolhido um modelo com 312 vértices para desenhar 104 triângulos que juntas
formam a imagem de carta. Fizemos um teste de desempenho usando o celular da lg modelo F240L, mas o
aplicativo estava gerando 8 frames por segundo, observamos que o resultado não foi satisfatório.
Decidimos usar um modelo com 6 vértices para desenhar 2 triângulos, como resultado o aplicativo
passou a gerar 71 frames por segundo.


Existem muitos tipos e modelos de aparelhos mobile e as dimenções da tela podem variar muito de modelo
para modelo, o que causa uma distorção na imagem desenhada na tela. Queremos que nosso aplicativo seja
capaz de fazer essa correção automaticamente, de tal modo que todos os vértices visíveis continuem
sendo visíveis após a correção.

Sejam respectivamente \( w, h \) o comprimento e altura de uma tela, a transformação viewport pode ser
descrita por uma transformação \(V_{w, h}\) que leva elementos de \(\mathbb{R}²\) para \(\mathbb{R}²\)
tal que \(\left(x, y\right) \mapsto \left(\frac{wx}{2}, \frac{hy}{2}\right)\).

Dizemos que \(D\) transformação que leva elementos de \(\mathbb{R}²\) para \(\mathbb{R}²\) é distorção
se existe \(\left(x, y\right) \in \mathbb{R}\) tal que \(x = y\) e
\(D\left(x, y\right) =  \left(x', y'\right) \to x' \neq y'\). Observe que se \( w \neq h \) então
\(V_{w, h}\) é distorção.

Dizemos que C transformação que leva elementos de \(\mathbb{R}²\) para \(\mathbb{R}²\) é correção da
distorção D se para todo \(\left(x, y\right) \in \mathbb{R}²\) tal que \(x = y\), temos
\(D \circ T \left(x, y\right) = \left(x', y'\right) \to x' = y'\).

Iremos mostrar que

$$
  T\left(x, y\right) =
    \left\{
      \begin{array}{cc}
	\left( \frac{hx}{w}, y \right) & \text{se } w > h \\
	\left( x, \frac{wy}{h} \right) & \text{c.c.}
      \end{array}
    \right.
$$

é correção da \(V_{w, h}\) e que se o vértice \(\left(x, y\right)\) é visível então
\(T\left(x, y\right)\) é visível.

Seja \(a \in \mathbb{R}\) e \(\left(x, y\right) \in \mathbb{R}²\) tal que \(x = y = a\). Se \(w > h\),
então \(V_{w, h} \circ T\left(x, y\right) = \left(\frac{ha}{2}, \frac{ha}{2}\right)\). Se
\(w \leq h\), então \(V_{w, h} \circ T\left(x, y\right) = \left(\frac{wa}{2}, \frac{wa}{2}\right)\).

Se \(w > h\) então \(T\left(x, y\right) = \left(\frac{hx}{w}, y\right)\) e temos
\(-1 \leq \left(\frac{hx}{w}, y\right) \leq 1\). Se \(w \leq h\) então
\(T\left(x, y\right) = \left(x, \frac{wy}{h} \right)\) e temos
\(-1 \leq \left(x, \frac{wy}{h}\right) \leq 1\).

Aplicamos a transformação \(T\) nos vértices no vertex shader e obtemos uma imagem sem deformação e com
todos os vértices que deviam ser mostrados na tela.


Para fazer que o aplicativo possa reconhecer o movimento para embaralha as cartas, fizemos uso do
classificador de k-vizinhos mais próximos. O problema que um classificador resolve é: Dada uma amostra
desconhecida, ele decide qual é a classe que ela representa. Em nosso exemplo de classificador de
movimentos, temos 2 classes: é movimento para embaralhar e não é.

Existe uma variedade de classificadores que podem ser utilizados para resolver este problema.
Escolhemos o classificador de k-visinhos mais próximos por ser 