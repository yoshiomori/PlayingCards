%% ------------------------------------------------------------------------- %%
%\chapter{Desenvolvimentos}
%\label{cap:desenvolvimentos}
%
%Embora neste exemplo tenhamos apenas um capítulo,  entre a introdução
%e a conclusão de uma monografia podemos ter uma sequência de capítulos
%descrevendo o trabalho e os resultados. Estes podem descrever
%fundamentos, trabalhos relacionados, método/modelo/algoritmo proposto,
%experimentos realizados, resulatdos obtidos.
%
%Cada capítulo pode ser organizado em seções, que por sua vez pode
%conter subseções.
%
%Um exemplo de figura está na figura~\ref{fig:graph}.
%\begin{figure}[htb]
%\includegraphics[width=5cm]{figuras/graph}
%\caption{\label{fig:graph}Exemplo de uma figura.}
%\end{figure}
\chapter{Desenhando objetos}
\label{cap:desenvolvimentos}
% O objetivo deste capítulo é expor as técnicas e decisões para gerar as imagens das cartas no
% celular

% Introduzir aos conceitos básicos de imagens, perspectiva, visão e objetos em relação á conputação
% gráfica, as tecnologias como biblioteca gráfica e bibliotecas do Android para desenvolvimento de
% aplicativos

% Explicar as decisões tomadas no desenvolvimento do GL(biblioteca gráfica no aplicativo). Explicar
% as abstrações que foram feitas para obter o GL.

% Mostras testes de experimento de tempo durante o processo de otimização.

Para desenhar imagens de cartas, fundo e botões na tela do celular, fizemos uso da interface de
programação de aplicações (API) do Android e do OpenGL.

O Android pode ser visto como uma camada de abstração da interface de manipulação da tela do celular e
do sensor de toque da tela disponibilisados pelos fabricantes. Nosso aplicativo faz uso desses
dispositivos, por meio desta camada e não iremos nos preocupar como essa abstração foi implementada.

Um aplicativo para Android é construido com componetes. Cada componete é um diferente ponto de entrada
do sistema. Existem quatro tipos diferentes de componetes: Activities, Services, Content providers e
Broadcast receivers, cada qual responsável por alguma funcionalidade dentro do aplicativo.

Nesta etapa de desenvolvimento, faremos uso da componete Activity. Uma activity representa uma tela
única com uma interface de usuário. Afim de gerar imagens para serem desenhadas nesta tela, faremos
uso do OpenGL ES.

O OpenGL é um conjunto de comandos que permitem a especificação de objetos geométricos em duas ou
três dimenções, junto com comandos que controlam como esses objetos são renderizados no
{\it framebuffer}. Esses objetos geométricos são construidos com {\it primitivas} que podem ser ponto,
segmento de linha, ou triângulo. As primitivas são definidas por um grupo de um ou mais vértices. Os
vértices definem um ponto, ponto final de uma aresta ou canto de um triângulo onde duas arestas se
encontram e são representados como um subconjunto de \(\mathbb{R}²\). Informações como coordenadas de
posição, cores, normal, coordenadas de textura podem estar associados a um vértice. As primitivas
formadas pelos vértices em \(\left\{\left(x, y\right) \in \mathbb{R}² | -1 \leq x, y \leq 1\right\}\)
são enviados para serem mostrados na tela, chamaremos esses vértices de visíveis.

Inicialmente haviamos escolhido um modelo com 312 vértices para desenhar 104 triângulos que juntas
formam a imagem de carta. Fizemos um teste de desempenho usando o celular da lg modelo F240L, mas o
aplicativo estava gerando 8 frames por segundo, observamos que o resultado não foi satisfatório.
Decidimos usar um modelo com 6 vértices para desenhar 2 triângulos, como resultado o aplicativo
passou a gerar 71 frames por segundo.


Existem muitos tipos e modelos de aparelhos mobile e as dimenções da tela podem variar muito de modelo
para modelo, o que causa uma distorção na imagem desenhada na tela. Queremos que nosso aplicativo seja
capaz de fazer essa correção automaticamente, de tal modo que todos os vértices visíveis continuem
sendo visíveis após a correção.

Sejam respectivamente \( w, h \) o comprimento e altura de uma tela, a transformação viewport pode ser
descrita por uma transformação \(V_{w, h}\) que leva elementos de \(\mathbb{R}²\) para \(\mathbb{R}²\)
tal que \(\left(x, y\right) \mapsto \left(\frac{wx}{2}, \frac{hy}{2}\right)\).

Dizemos que \(D\) transformação que leva elementos de \(\mathbb{R}²\) para \(\mathbb{R}²\) é distorção
se existe \(\left(x, y\right),\left(x', y'\right) \in \mathbb{R}²\) tal que \(x = y\),
\(D\left(x, y\right) =  \left(x', y'\right)\) e \(x' \neq y'\). Observe que se \( w \neq h \)
então \(V_{w, h}\) é distorção.

Dizemos que C transformação que leva elementos de \(\mathbb{R}²\) para \(\mathbb{R}²\) é correção da
distorção D se para todo \(\left(x, y\right), \left(x', y'\right) \in \mathbb{R}²\) tal que \(x = y\)
e \(D \circ T \left(x, y\right) = \left(x', y'\right)\), temos \(x' = y'\).

Iremos mostrar que

$$
  T\left(x, y\right) =
    \left\{
      \begin{array}{cc}
	\left( \frac{hx}{w}, y \right) & \text{se } w > h \\
	\left( x, \frac{wy}{h} \right) & \text{c.c.}
      \end{array}
    \right.
$$

é correção da \(V_{w, h}\) e que se o vértice \(\left(x, y\right)\) é visível então
\(T\left(x, y\right)\) é visível.

Seja \(a \in \mathbb{R}\) e \(\left(x, y\right) \in \mathbb{R}²\) tal que \(x = y = a\). Se \(w > h\),
então \(V_{w, h} \circ T\left(x, y\right) = \left(\frac{ha}{2}, \frac{ha}{2}\right)\). Se
\(w \leq h\), então \(V_{w, h} \circ T\left(x, y\right) = \left(\frac{wa}{2}, \frac{wa}{2}\right)\).

Seja \(\left(x, y\right) \in \mathbb{R}²\) visível. Se \(w > h\) então
\(T\left(x, y\right) = \left(\frac{hx}{w}, y\right)\) e temos
\(-1 \leq \left(\frac{hx}{w}, y\right) \leq 1\). Se \(w \leq h\) então
\(T\left(x, y\right) = \left(x, \frac{wy}{h} \right)\) e temos
\(-1 \leq \left(x, \frac{wy}{h}\right) \leq 1\).

Aplicamos a transformação \(T\) nos vértices no vertex shader e obtemos uma imagem sem deformação e
com todos os vértices que deviam ser mostrados na tela.

Para mover as cartas, o usuário deve tocar na carta e arrastá-la. A API do Android nos permite saber a
posição do toque na tela, mas ainda precisamos saber se existe alguma carta nesta posição. Existem
duas soluções para este problema.

A primeira solução consiste em gerar uma imagem em preto e branco para cada carta, onde a carta é
desenhada em branco no fundo preto. Para verificar que a posição do toque contem uma carta, basta ler
o pixel correspondente à posição do toque. Se o pixel for branco, então a carta foi tocada. Contudo, o
acesso ao framebuffer para leitura do valor do pixel é restrito apenas para o sistema e não pudemos
implementar esta solução.

Assim, passamos para a segunda solução. Aplicaremos a transformação inversar da
\(V_{w, h} \circ T\left(x, y\right)\) nas coordenadas do toque para obtermos um ponto na mesma
coordenada dos vértices que geram a imagem da carta. Dessa forma podemos verificar se o ponto está
entre os vértices da carta.

Para embaralhar, o usuário deve selecionar todas as cartas arrastar para cima e para baixo pelo menos 
3 vezes. Assim, temos duas classes de movimento, uma para embaralhar e outra só para movimentar. A
solução para este problema foi aplicar o classificador de k vizinhos próximos que é um método para
resolver problemas de aprendizagem supervisionada.

O classificador de k vizinhos mais próximos recebe \(X\) conjunto de entrada e \(Y\) conjunto de saída
tais que a \(i\)-ésima observação de \(x_i\in X\) está associado ao \(i\)-ésimo elemento \(y_i\in Y\).
chamaremos o conjunto de todas as associações entre \(X\) e \(Y\) de conjunto de treinamento.

Seja x 
O método é fazer observações nos k elementos mais próximo à x nova entrada do conjunto de entrada.